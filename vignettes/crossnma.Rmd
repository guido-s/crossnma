---
title: "crossnma to synthesize cross-design evidence and cross-format data using network meta-analysis"
author: "Tasnim Hamza and Georgia Salanti"
date: "`r Sys.Date()`"
output: 
  knitr:::html_vignette:
   toc: true
   number_sections: true
bibliography: references.bib 
vignette: >
  %\VignetteIndexEntry{crossnma}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning=FALSE
)
```

```{r mm, warning=FALSE,message=FALSE,include=FALSE}
devtools::install_github("htx-r/crossnma",force = TRUE)
library(crossnma)
library(rjags) # only for bias.method='adjust2' - to use the function load.module() 
load.module('mix') # only for bias.method='adjust2' - to call the bimodal normal models to JAGS
```

# Introduction 

In network meta-analysis we synthesize all relevant available evidence about health outcomes from competing treatments. That evidence might come from different study designs and in different formats: from non-randomized studies (NRS) or randomized controlled trials (RCT) as individual participant data (IPD) or as aggregate data (AD). We set up the package `crossnma` to synthesize all available evidence.

This document demonstrates how to use `crossnma` to synthesize cross-design evidence and cross-format data via Bayesian network meta-analysis and meta-regression (NMA and NMR). All models are implemented in JAGS [@plummer_jags].

We describe the workflow within the package using a worked example from a network meta-analysis of studies for treatments in  relapsing remitting multiple sclerosis (RRMS). The primary outcome is the occurrence of relapses in two years (binary outcome). In the analysis, the relative effect will be the odds ratio (OR). The aim is to compare the efficacy of four treatments using the data from 6 different studies in different formats and different designs. 

# The synthesis models

We first introduce the model that synthesizes studies  with individual-level (IPD) or/and aggregate data (AD) ignoring their design (unadjusted   synthesis).  Then, we present three possible models that account for the different study designs. In the table below we set the notation that will be used in the description of the four models. 

| Notation 	| Description| Argument in `crossnma.model()`| 
|:-------------------|:-----------|:------|
|$i=1, ..., np_j$ | participant id|  |
|$j=1, ..., ns$ | study id|  |
|$k=1, ..., K$ | treatment index|  |
|$ns_{IPD}, ns_{AD}, ns_{RCT}, ns_{NRS}$| the number of studies. The index refers to the design or format of the study|  |
|$y_{ijk}$ | binary outcome (0/1)| `outcome` |
|$p_{ijk}$ | probability of the event to occur| |
|$r_{jk}$ | the number of events per arm| `outcome` |
|$n_{jk}$ | the sample size per arm| `n` |
|$b$ |the study-specific reference|*|
|$u_{jb}$ | The treatment effect of the study-specific reference $b$ | |
|$\delta_{jbk}$|log(OR) of treatment k relative to $b$||
|$x_{ijk}$|the covariate|`covariate`|
|$\bar{x}_{j}$|the mean covariate for study $j$||
|$d_{Ak}$| the basic parameters. Here, $d_{AA}=0$ when A set as the reference in the network|use `reference` to assign the reference treatment|
|$z_j$| study characteristics to estimate the bias probability $\pi_j$| `bias.covariate` |
|$w$| common inflation factor of variance for the NRS estimates | the element `var.infl` in `run.nrs`|
|$\zeta$| common mean shift of the NRS estimates | the element `mean.shift` in `run.nrs`|
*If the reference in the network ($A$) is available on the study, it is assigned automatically to that reference.  If not, it is assigned to the first alphabetically ordered treatment on the study.

## Unadjusted synthesis
We synthesize the evidence from RCT and NRS without acknowledging the differences between them. We combine the IPD data from RCT and NRS in one model and we do the same in another model with the AD information. Then, we combine the estimates from both parts as described in Section 2.5.

**model IPD only**

$$
y_{ijk} \sim Bernoulli(p_{ijk})
$$
\begin{equation}
  logit(p_{ijk}) =
    \begin{cases}
      u_{jb} +\beta_{0j} x_{ijk} & \text{if $k=b$}\\
      u_{jb} +\delta_{jbk} + \beta_{0j}x_{ijk}+\beta^w_{1,jbk}x_{ijk} +
 (\beta^B_{1,jbk}-\beta^w_{1,jbk}) \bar{x}_{j} & \text{if $k≠b$}
    \end{cases}       
\end{equation}

**model AD only**
$$
r_{jk} \sim Binomial(p_{jk},n_{jk})
$$
\begin{equation}
  logit(p_{.jk}) =
    \begin{cases}
      u_{jb}  & \text{if $k=b$}\\
      u_{jb} +\delta_{jbk} +\beta^B_{1,jbk} \bar{x}_{j} & \text{if $k≠b$}
    \end{cases}       
\end{equation}

## Using non-randomized studies (NRS) as a prior

First we estimate the relative treatment effects using only the NRS (use `run.nrs` in `crossnma.model()` to control this process). Then we use the NRS estimates ($\tilde{d}^{NRS}_{Ak},V^{NRS}_{Ak}$) as a prior information for the basic parameters of RCT data, $d_{Ak} \sim N(\tilde{d}^{NRS}_{Ak},V^{NRS}_{Ak})$. To control the NRS influence in the RCT estimates, we can either inflate the prior variance by dividing it by a common inflation factor $w$ (the inflated variances are $V^{NRS}_{Ak}/w$) or shift the NRS means by $\zeta$.

## Bias-adjusted model 1

In this and the next model we incorporate the judgments about the study risk of bias (RoB) in the model. Each the judgement about the risk of bias in a study is summarized by the index $R_j$ which takes values 0 (no bias) or 1 (bias). In bias-adjusted model 1, we extend the method introduced by @dias_2010 by adding a treatment-specific bias term $\gamma_{2,jbk} R_j$ to the relative treatment effect on both the AD and IPD parts of the model. A multiplicative model can also be employed, where treatment effects are multiplied by $\gamma_{1,jbk}^{R_j}$. The models in previous section are extended as follows.

**model IPD only**

\begin{equation}
  logit(p_{ijk}) =
    \begin{cases}
      u_{jb} +\beta_{0j} x_{ijk} & \text{if $k=b$}\\
      u_{jb} +\delta_{jbk}*\gamma_{1,j}^{R_j}+\gamma_{2,j} R_j+ \beta_{0j}x_{ijk}+\beta^w_{1,jbk} x_{ijk}+
 (\beta^B_{1,jbk}-\beta^w_{1,jbk}) \bar{x}_{j} & \text{if $k≠b$}
    \end{cases}       
\end{equation}

**model AD only**

\begin{equation}
  logit(p_{jk}) =
    \begin{cases}
      u_{jb}  & \text{if $k=b$}\\
      u_{jb} +\delta_{jbk} *\gamma_{1,j}^{R_j}+\gamma_{2,j} R_j+
 \beta^B_{1,jbk} \bar{x}_{j} & \text{if $k≠b$}
    \end{cases}       
\end{equation}

where the bias indicator $R_j$ follows the following distribution

$$
R_j \sim Bernoulli(\pi_j)
$$

The bias probabilities $\pi_j$ are study-specific and can be estimated in two different ways. They are either given informative beta priors (${Beta(a_1,a_2)}$) that are set according to the risk of bias. The default beta priors are as follows: high bias RCT `pi.high.rct='dbeta(10,1)'`, low bias RCT `pi.low.rct='dbeta(1,10)'`, high bias NRS `pi.high.nrs='dbeta(30,1)'` and low bias NRS `pi.low.nrs='dbeta(1,30)'`. The ratio ${a_1/a_2}$ controls the skewness of the beta distribution.  The closer to 1 the ratio $a_1/a_2$, the more the mean of probability of bias gets closer to 1 and the study acquires 'major' bias adjustment. Alternatively,  we can use the study characteristics $z_j$ to predict $\pi_j$ through a logistic transformation (internally coded).
We combine the multiplicative and the additive treatment-specific bias effects across studies by assuming they are exchangeable $\gamma_{1,jbk}\sim Ν(g_{1,bk},τ_{1,\gamma}^2 )$,$\gamma_{2,jbk}\sim Ν(g_{2,bk},τ_{2,\gamma}^2 )$) or common $\gamma_{1,jbk}=g_{1,bk}$ and $\gamma_{2,jbk}=g_{2,bk}$. Dias et al. @dias_2010 proposed to model the mean bias effect $(g_{1,bk}, g_{2,bk})$ based on the treatments being compared. One approach is to assume a common mean bias for studies that compare active treatments with an inactive treatment (placebo, standard or no treatment)  
\begin{equation}
  g_{m,bk} =
    \begin{cases}
      g_m  & \text{if $b$ is inactive treatment}\\
      0 & \text{if $b$ and $k$ are active treatments}
    \end{cases}       
\end{equation}

Instead of assuming zero bias in active vs active comaprison, we could assume a common and fixed bias effect $g_m^{act}$
\begin{equation}
  g_{m,bk} =
    \begin{cases}
      g_m  & \text{if $b$ is inactive treatment}\\
      (-1)^{dir_{bk}} g_m^{act} & \text{if $b$ and $k$ are active treatments}
    \end{cases}       
\end{equation}
The direction of bias $dir_{bk}$ varies by the comparison type and should be defined in the data. The bias in active vs inactive comaprisons will favor the active treatment. The direction of bias in studies that have active-active comparisons is set to be either 0, meaning that bias favors $b$ over $k$, or 1 , meaning that $k$ is favored to $b$.  In `crossnma.model()`, the direction of bias can be determined by providing `unfav` and `bias.group` for each study in the dataset.

## Bias-adjusted model 2

Another way to incorporate the RoB of the study is by replacing $\delta_{jbk}$ by a "bias-adjusted" relative treatment effect $\theta_{jbk}$. Then $\theta_{jbk}$ is modeled with a bimodal normal distribution as described in Section 2.5. For more details see @verde_2020.

**model IPD only**

\begin{equation}
  logit(p_{ijk}) =
    \begin{cases}
      u_{jb} +\beta_{0j} x_{ijk} & \text{if $k=b$}\\
      u_{jb} +\theta_{jbk} + \beta_{0j} x_{ijk}+\beta^w_{1,jbk} x_{ijk}+
 (\beta^B_{1,jbk}-\beta^w_{1,jbk}) \bar{x}_{j} & \text{if $k≠b$}
    \end{cases}       
\end{equation}

**model AD only**

\begin{equation}
  logit(p_{jk}) =
    \begin{cases}
      u_{jb} & \text{if $k=b$}\\
      u_{jb} +\theta_{jbk} +\beta^B_{1,jbk} \bar{x}_{j} & \text{if $k≠b$}
    \end{cases}       
\end{equation}

where the bias-adjusted relative treatment effect ($\theta_{jk}$) are modeled  via random-effects model with a mixture of two normal distributions.
$$
\theta_{jbk} \sim (1-\pi_j) N(d_{Ak}-d_{Ab}, \tau^2) +  \pi_j N(d_{Ak}-d_{Ab}+\gamma_{jbk}, \tau^2+\tau_\gamma^2)
$$

Alternatively, we can summarize these relative effects assuming a common-effect model
$$
\theta_{jbk}= d_{Ak}-d_{Ab}+\pi_j \gamma_{jbk}
$$

## Assumptions about the model parameters

The table below summarizes the different assumptions implemented in the package about combining the parameters in the models described above. 

| Parameter 	| Assumptions| Argument in `crossnma.model()`|  	
|:----------------------|:-----------|:------|
|relative treatment effect ($\delta_{jbk}$)| Random-effects: $\delta_{jbk}\sim N(d_{Ak}-d_{Ab}, \tau^2)$| `trt.effect='random'` |
| |Common-effect: $\delta_{jbk}=d_{Ak}-d_{Ab}$| `trt.effect='common'`|
|Covariate effect $\beta_{0j}$ | Independent effects: $\beta_{0j} \sim N(0, 10^2)$| `reg0.effect='independent'` |
|  |Random-effects: $\beta_{0j} \sim N(B_0, \tau_{\beta_0})$| `reg0.effect='random'`|
|Within-study covariate-treatment interaction ($\beta_{1,jbk}^W$)| Random-effects: $\beta_{1,jbk}^W \sim N(B_{1,Ak}^W-B_{1,Ab}^W, \tau_{W})$| `regw.effect='random'` |
| 	|Common-effect: $\beta_{1,jbk}^W = B_{1, Ak}^W-B_{1, Ab}^W$| `regw.effect='common'`|
|Between-study covariate-treatment interaction ($\beta_{1,jbk}^B$)| Random-effects: $\beta_{1,jbk}^B \sim N(B_{1, Ak}^B-B_{1, Ab}^B, \tau_B)$| `regb.effect='random'` |
|  	|Common-effect: $\beta_{1,jbk}^B = B_{1, Ak}^B-B_{1, Ab}^B$| `regb.effect='common'`|
|Bias effect ($\gamma_{m,jbk}$), $m={1,2}$| Random-effects: $\gamma_{m,jbk} \sim N(g_{m, bk}, \tau_{\gamma})$| `bias.effect='random'` |
| 	|Common-effect: $\gamma_{m,jbk}=g_{m,bk}$| `bias.effect='common'`|
|Mean bias effect $g_{m,bk}$|No bias effect on active-active: \begin{equation}
  g_{m,bk} =
    \begin{cases}
      g_m  & \text{if $b$ is inactive treatment}\\
      0 & \text{if $b$ and $k$ are active treatments}
    \end{cases}       
\end{equation}|`unfav = 0 (inactive), 1 (active)` and `bias.group=1` $(g_{m,bk}=g)$ or `0`$(g_{m,bk}=g_m^{act})$|
||A mean bias effect $g_m^{act}$ on active-active:\begin{equation}
  g_{m,bk} =
    \begin{cases}
      g_m  & \text{if $b$ is inactive treatment}\\
      (-1)^{dir_{bk}} g_m^{act} & \text{if $b$ and $k$ are active treatments}
    \end{cases}       
\end{equation}|`unfav = 0 (inactive), 1 (active)` and `bias.group=1` $(g_{m,bk}=g_m)$ or `2` $(g_{m,bk}=g_m^{act})$|
|Bias probability ($\pi_j$)| $\pi_j \sim Beta(a,b)$|  |
|| $\pi_j = e+fz_j$|  |

# Synthesis of studies comparing drugs for relapsing-remitting multiple sclerosis

## Description of the data
The data we use are fictitious but have been developed to resample to real RCTs with IPD and aggregate data included in @Tramacere15. The studies provide either aggregate data `std.data` (2 RCTs) or as individual participant data `prt.data` (3 RCTs and 1 cohort study). Both datasets compare in total four drugs which are anonymized.

The `prt.data` contains 2950 rows, each row refers to a participant in the study. We display the first few rows of the data set:

```{r}
head(prt.data)
```

For each participant, we have information for the `outcome` relapse (0=no, 1=yes), the treatment label `trt`, the `age` (in years) and  `sex` (0 = Female, 1 = Male) of the participant. The following columns are set on study-level (it is repeated for each participant in each study): the `study` id, the `design` of the study (needs to be either rct or nrs), the risk of `bias` on each study (can be set as low, high or unclear) and the `year` of publication .

The aggregate data has the standard format for meta-analysis

```{r}
head(std.data)
```

## Analysis

The network should be checked for its connectivity before running the analysis. This is a vital step as the model will run even if the network is not connected.


```{r}
#netplot(prt.data,std.data)
```


In the following table, we summarize the number of studies from each design and each data format:

```{r}
#knitr::kable(ns.tab(prt.data,std.data))
```


There are two steps to run the NMA/NMR model. The first step is to create a JAGS model using `crossnma.model()` which produces the JAGS code and the data. In the second step, the output of that function will be used in `crossnma.run()` to run the analysis through JAGS. 

### Unadjusted   network meta-analysis 

We start by indicating the names of the datasets on participant-level (`prt.data`) and aggregate data (`std.data`). Then, the name of the variables on both datasets should be the same.  Next, the `reference` treatment needs to be assigned (we set it to drug A). By choosing `trt.effect=random`, we are assigning a normal distribution to each relative treatment effect to allow the synthesis across studies, see the table in Section 2.1. Finally, the different designs; RCT and NRS are combined with the information taken at face-value; `method.bias = 'naive'`.

Optionally, we can specify a prior to the common heterogeneity of the treatment effect across studies. We indicate that distribution in the argument `prior` as `tau.trt='dunif(0,3)'`, see below.


```{r}
# jags model: code+data
 mod1 <- crossnma.model(prt.data=prt.data,
                   std.data=std.data,
                   trt='trt',
                   study='study',
                   outcome='outcome',
                   n='n',
                   design='design',
                   trt.effect='random',
                   reference='A',
                   method.bias = 'naive',
                   #---------- assign a prior ----------
                   prior=list(tau.trt='dunif(0,3)')
                    )
```

Next, we fit the NMA model using `crossnma.run()`which requires us to set the number of adaptations, iterations, thinning and chains.

```{r}
# run jags
jagsfit1 <- crossnma.run(model=mod1,
                        n.adapt = 50,
                        n.iter=500,
                        n.burnin = 200,
                        thin=1,
                        n.chains=2)
```

We summarize the estimated parameters in the following table. 

```{r}
knitr::kable(summary(jagsfit1,expo=F))
```

The estimated OR of B vs A can be obtained as exp(d.B) and similarly for exp(d.C) and exp(d.D) are the ORs of C and D relative to A, respectively. The value of tau refers to the estimates of the heterogeneity standard deviation in the relative treatment effects across studies.

We need also to assess the convergence of the MCMC chains either by visually inspect the trace plot or checking the Gelman and Rubin statistic, Rhat (it should be approximately 1) in the table above.

```{r,out.width='.49\\linewidth', fig.width=3, fig.height=3,fig.show='hold',fig.align='center'}
coda::traceplot(jagsfit1$samples)
```

### Unadjusted network meta-regression 
In this part, we run NMR model by adding age as a covariate from both datasets. We set a list of elements `covariate='age'` representing the name of the covariate in `prt.data` and `std.data`.

```{r}
# jags model: code+data
mod2 <- crossnma.model(prt.data=prt.data,
                   std.data=std.data,
                   trt='trt',
                   study='study',
                   outcome='outcome',
                   n='n',
                   design='design',
                   reference='A',
                   trt.effect='random',
                   #----------  meta-regression ----------
                   covariate = 'age',
                   split.regcoef = F,
                   #---------- bias adjustment ----------
                   method.bias='naive'
                   )
```

The MCMC is run under the same set up as in the network meta-analysis.

```{r}
# run jags
jagsfit2 <- crossnma.run(model=mod2,
                        n.adapt = 50,
                        n.iter=500,
                        n.burnin = 200,
                        thin=1,
                        n.chains=2)
```

and the output table is presented below

```{r}
knitr::kable(summary(jagsfit2,expo=FALSE))
```

Now, we additionally estimate b_1 which indicates the mean effect of age and tau.b_1 which refers to the heterogeneity standard deviation in the effect of age across studies. Here, we obtain a single estimate  because we choose to not split the within- and between-study age coefficients $(\beta^w_{1,jbk} = \beta^B_{1,jbk}=\beta_{1,jbk})$ to improve the convergence of MCMC.

Again, we check convergence with trace plots

```{r,out.width='.49\\linewidth', fig.width=3, fig.height=3,fig.show='hold',fig.align='center'}
coda::traceplot(jagsfit2$samples)
```

### Using non-randomized studies as a prior in network meta-regression

To run NMA with a prior from NRS, two additional arguments are needed: we indicate using NRS as a prior by setting ` method.bias='prior'`. That means that the model runs internally NMA with only NRS data which are then used to construct informative priors. This requires defining MCMC settings (the number of adaptations, iterations, burn-ins, thinning and chains) in the argument `run.nrs`. 

In this method, the prior for the basic parameters is set to a normal distribution. For basic parameters not examined in the NRS, the code sets a minimally informative prior `d~dnorm(0, 1e-2)`. To account for possible bias, the means of the distribution can be shifted by `mean.shift` to reflect the potential bias in NRS and/or the variance can be inflated by `var.infl` to control the influence of NRS on the final estimation. Both should be provided in `run.nrs`.

```{r}
# jags model: code+data
mod3 <- crossnma.model(prt.data=prt.data,
                   std.data=std.data,
                   trt='trt',
                   study='study',
                   outcome='outcome',
                   n='n',
                   design='design',
                   reference='D',
                   trt.effect='random',
                   #----------  meta-regression ----------
                   covariate = 'age',
                   split.regcoef = F,
                   #---------- bias adjustment ----------
                   method.bias='prior',
                   run.nrs=list(var.infl=0.6,
                                n.adapt = 500,
                                n.iter=10000,
                                n.burnin = 4000,
                                thin=1,
                                n.chains=2))
```


```{r}
# run jags
jagsfit3 <- crossnma.run(model=mod3,
                        n.adapt = 50,
                        n.iter=500,
                        n.burnin = 200,
                        thin=1,
                        n.chains=2)
```


```{r}
knitr::kable(summary(jagsfit3,expo=F))
```


```{r,out.width='.49\\linewidth', fig.width=3, fig.height=3,fig.show='hold',fig.align='center'}
coda::traceplot(jagsfit3$samples)
```


###   Bias-adjusted model 1
In this part, the overall relative treatment effects are estimated from both NRS and RCT with adjustment to study-specific bias.

To fit the model, we set `method.bias='adjust1'` and we need to provide the name of the bias variable `bias='bias'` in the datasets. The direction of bias is determined by the column `unfav='unfav'` which indicates the unfavoured treatment. The mean bias effect can be set at $0$, $g$ or $g^{act}$ and this is indicated by `bias.group='bias.group'` column (default is `bias.group=1` which means the mean bias effect =$g$). By default, the effect of bias is assumed to be additive `bias.type='add'` and equal across studies `bias.effect='common'`. We also use  the `year` of study publication to estimate the study-probability of bias, `bias.covariate = 'year'`. 


```{r}
# jags model: code+data
mod4 <- crossnma.model(prt.data=prt.data,
                   std.data=std.data,
                   trt='trt',
                   study='study',
                   outcome='outcome',
                   n='n',
                   design='design',
                   reference='A',
                   trt.effect='random',
                   #---------- bias adjustment ----------
                   method.bias='adjust1',
                   bias='bias',
                   bias.type='add',
                   unfav='unfav',
                   bias.group="bias.group",
                   bias.effect='common',
                   bias.covariate = 'year'
                  )
```



```{r}
# run jags
jagsfit4 <- crossnma.run(model=mod4,
                       n.adapt = 50,
                        n.iter=500,
                        n.burnin = 200,
                        thin=1,
                        n.chains=2)
```

The results are presented below

```{r}
knitr::kable(summary(jagsfit4,expo=F))
```

The parameter `g` refers to the mean bias effect, common for all studies.

The trace plots are shown below

```{r,out.width='.49\\linewidth', fig.width=3, fig.height=3,fig.show='hold',fig.align='center'}
coda::traceplot(jagsfit4$samples)
```


###   Bias-adjusted model 2

The arguments for `method.bias='adjust2'` are similar to the ones used before in `method.bias='adjust1'`.

```{r}
# jags model: code+data
mod5 <- crossnma.model(prt.data=prt.data,
                   std.data=std.data,
                   trt='trt',
                   study='study',
                   outcome='outcome',
                   n='n',
                   design='design',
                   reference='A',
                   trt.effect='random',
                   #---------- bias adjustment ----------
                   method.bias='adjust2',
                   bias='bias',
                   bias.type='add',
                   unfav='unfav',
                   bias.group="bias.group",
                   bias.effect='common'
                   )
```


```{r}
# run jags
jagsfit5 <- crossnma.run(model=mod5,
                       n.adapt = 50,
                        n.iter=500,
                        n.burnin = 200,
                        thin=1,
                        n.chains=2)
```



```{r}
knitr::kable(summary(jagsfit5,expo=F))
```



```{r,out.width='.49\\linewidth', fig.width=3, fig.height=3,fig.show='hold',fig.align='center'}
coda::traceplot(jagsfit5$samples)
```


# References


